# 视频下载器技术文档

## 项目概述

本项目是一个基于 Go 语言开发的统一视频下载器，支持 TikTok、小红书(XHS)、快手等多个主流短视频平台。项目采用模块化设计，具有良好的可扩展性和维护性。

## 系统架构

### 核心组件

```
video-downloader/
├── cmd/                    # 应用程序入口点
│   ├── cli/               # CLI 命令行工具
│   └── server/            # API 服务器
├── internal/              # 内部包
│   ├── auth/              # JWT 认证中间件
│   ├── config/            # 配置管理
│   ├── downloader/        # 下载管理器
│   ├── monitor/           # 监控和指标
│   ├── platform/          # 平台适配器
│   │   ├── tiktok/        # TikTok 实现
│   │   ├── xhs/           # 小红书实现
│   │   └── kuaishou/      # 快手实现
│   ├── ratelimit/         # 限流实现
│   ├── registry/          # 服务注册
│   ├── server/            # HTTP 服务器
│   ├── storage/           # 数据存储
│   └── utils/             # 工具函数
├── pkg/                   # 公共包
│   ├── api/               # API 模型
│   └── models/            # 数据模型
```

### 核心接口设计

#### 1. PlatformExtractor 接口

```go
type PlatformExtractor interface {
    ExtractVideoInfo(url string) (*VideoInfo, error)
    ExtractAuthorInfo(authorID string) (*AuthorInfo, error)
    ExtractBatch(url string, limit int) ([]*VideoInfo, error)
    ValidateURL(url string) bool
    GetName() Platform
    GetSupportedURLPatterns() []string
}
```

#### 2. Downloader 接口

```go
type Downloader interface {
    Download(url, filePath string, progressChan chan<- float64) error
    GetFileSize(url string) (int64, error)
    SupportsResume() bool
    GetSupportedFormats() []string
}
```

#### 3. Storage 接口

```go
type Storage interface {
    SaveVideoInfo(info *VideoInfo) error
    GetVideoInfo(id string) (*VideoInfo, error)
    ListVideos(filter VideoFilter) ([]*VideoInfo, error)
    UpdateVideoStatus(id, status string) error
    SaveDownloadTask(task *DownloadTask) error
    SaveAuthorInfo(info *AuthorInfo) error
    // ... 其他方法
}
```

## 各平台技术实现详解

### 1. TikTok 平台

#### 技术原理
TikTok 的视频下载主要通过以下步骤实现：

1. **URL 解析**：从分享链接中提取视频 ID
2. **API 调用**：使用移动端 API 获取视频数据
3. **数据解析**：解析 API 返回的 JSON 数据
4. **URL 提取**：从响应中提取视频下载地址

#### 核心实现

```go
// 提取视频 ID
func (e *tiktokExtractor) extractVideoID(url string) (string, error) {
    re := regexp.MustCompile(`(?:video/|t/|vm\.tiktok\.com/)(\d+)`)
    matches := re.FindStringSubmatch(url)
    if len(matches) < 2 {
        return "", fmt.Errorf("invalid TikTok URL format")
    }
    return matches[1], nil
}

// 获取视频数据
func (e *tiktokExtractor) getVideoData(videoID string) (*TikTokVideo, error) {
    apiURL := fmt.Sprintf("https://api2.musical.ly/aweme/v1/feed/?aweme_id=%s", videoID)

    headers := map[string]string{
        "Accept":          "application/json",
        "Accept-Language": "en-US,en;q=0.9",
        "Referer":         "https://www.tiktok.com/",
    }

    resp, err := e.client.Get(apiURL, headers)
    if err != nil {
        return nil, fmt.Errorf("error fetching video data: %w", err)
    }
    defer resp.Body.Close()

    // 解析响应...
}
```

#### 数据结构

```go
type TikTokVideo struct {
    ID          string `json:"id"`
    Desc        string `json:"desc"`
    CreateTime  int64  `json:"create_time"`
    Video       Video  `json:"video"`
    Author      Author `json:"author"`
    Stats       Stats  `json:"stats"`
    Music       Music  `json:"music"`
}

type Video struct {
    PlayAddr     VideoURL `json:"play_addr"`
    DownloadAddr VideoURL `json:"download_addr"`
    Cover        VideoURL `json:"cover"`
    Duration     int      `json:"duration"`
    Format       string   `json:"format"`
    Height       int      `json:"height"`
    Width        int      `json:"width"`
}
```

#### 技术特点

- **API 方式**：使用官方移动端 API，数据获取稳定
- **用户代理**：模拟 iOS 设备访问，降低被封风险
- **Cookie 支持**：支持自定义 Cookie，提高成功率
- **多 URL 格式**：支持多种 URL 格式解析

### 2. 小红书 (XHS) 平台

#### 技术原理
小红书的内容获取采用网页解析的方式：

1. **URL 解析**：从链接中提取笔记 ID
2. **网页获取**：获取网页 HTML 内容
3. **数据提取**：从 HTML 中的 JSON 数据提取信息
4. **短链解析**：支持短链接重定向解析

#### 核心实现

```go
// 从 HTML 中提取笔记数据
func (e *xhsExtractor) extractNoteFromHTML(body io.Reader) (*XHSNote, error) {
    doc, err := html.Parse(body)
    if err != nil {
        return nil, fmt.Errorf("error parsing HTML: %w", err)
    }

    var noteData *XHSNote
    var f func(*html.Node)
    f = func(n *html.Node) {
        if n.Type == html.ElementNode && n.Data == "script" {
            for _, attr := range n.Attr {
                if attr.Key == "id" && attr.Val == "__NEXT_DATA__" {
                    if n.FirstChild != nil {
                        var nextData map[string]interface{}
                        if err := json.Unmarshal([]byte(n.FirstChild.Data), &nextData); err == nil {
                            noteData = e.parseNextData(nextData)
                            return
                        }
                    }
                }
            }
        }
        for c := n.FirstChild; c != nil; c = c.NextSibling {
            f(c)
        }
    }
    f(doc)

    return noteData, nil
}
```

#### 数据结构

```go
type XHSNote struct {
    ID           string      `json:"id"`
    Title        string      `json:"title"`
    Desc         string      `json:"desc"`
    Type         string      `json:"type"`
    CreateTime   int64       `json:"create_time"`
    User         XHSUser     `json:"user"`
    Images       []XHSImage  `json:"images"`
    Video        XHSVideo    `json:"video"`
    Tags         []string    `json:"tags"`
    InteractInfo InteractInfo `json:"interact_info"`
}

type XHSVideo struct {
    PlayAddr string `json:"play_addr"`
    Duration int    `json:"duration"`
    Width    int    `json:"width"`
    Height   int    `json:"height"`
    Cover    string `json:"cover"`
}
```

#### 技术特点

- **网页解析**：解析 Next.js 应用的 __NEXT_DATA__ 数据
- **多媒体支持**：支持视频和图文内容
- **短链处理**：自动解析短链接重定向
- **反爬处理**：使用浏览器 User-Agent 降低被封风险

### 3. 快手 (Kuaishou) 平台

#### 技术原理
快手的内容获取同样采用网页解析：

1. **URL 解析**：从链接中提取视频 ID
2. **网页获取**：获取网页 HTML 内容
3. **数据提取**：从 Apollo State 中提取视频信息
4. **数据转换**：将复杂数据结构转换为标准格式

#### 核心实现

```go
// 从 HTML 中提取视频数据
func (e *kuaishouExtractor) extractVideoFromHTML(body io.Reader) (*KSVideo, error) {
    doc, err := html.Parse(body)
    if err != nil {
        return nil, fmt.Errorf("error parsing HTML: %w", err)
    }

    var videoData *KSVideo
    var f func(*html.Node)
    f = func(n *html.Node) {
        if n.Type == html.ElementNode && n.Data == "script" {
            if n.FirstChild != nil {
                scriptContent := n.FirstChild.Data
                if strings.Contains(scriptContent, "window.__APOLLO_STATE__") {
                    start := strings.Index(scriptContent, "{")
                    end := strings.LastIndex(scriptContent, "}")
                    if start != -1 && end != -1 {
                        jsonData := scriptContent[start : end+1]
                        var apolloData KSWebData
                        if err := json.Unmarshal([]byte(jsonData), &apolloData); err == nil {
                            videoData = e.parseApolloData(apolloData)
                            return
                        }
                    }
                }
            }
        }
        for c := n.FirstChild; c != nil; c = c.NextSibling {
            f(c)
        }
    }
    f(doc)

    return videoData, nil
}
```

#### 数据结构

```go
type KSVideo struct {
    PhotoID     string      `json:"photoId"`
    Caption     string      `json:"caption"`
    Duration    int         `json:"duration"`
    CreateTime  int64       `json:"timestamp"`
    User        KSUser      `json:"user"`
    Photo       KSPhoto     `json:"photo"`
    SoundTrack  KSSound     `json:"soundTrack"`
    ExtParams   KSExtParams `json:"ext_params"`
}

type KSPhoto struct {
    ID          string    `json:"id"`
    Duration    int       `json:"duration"`
    Width       int       `json:"width"`
    Height      int       `json:"height"`
    CoverURL    string    `json:"coverUrl"`
    PhotoType   string    `json:"photoType"`
    ViewCount   int       `json:"viewCount"`
    LikeCount   int       `json:"likeCount"`
    CoverUrls   []KSURL   `json:"coverUrls"`
}
```

#### 技术特点

- **Apollo State**：解析 React Apollo 的客户端状态
- **复杂数据**：处理嵌套的数据结构
- **多媒体类型**：支持视频和图集内容
- **CDN 处理**：支持多 CDN 节点下载

## 平台对比分析

### 技术实现对比

| 特性 | TikTok | 小红书 (XHS) | 快手 (Kuaishou) |
|------|--------|-------------|----------------|
| 数据获取方式 | 移动端 API | 网页解析 | 网页解析 |
| 数据源 | JSON API | __NEXT_DATA__ | __APOLLO_STATE__ |
| URL 格式支持 | 多种格式 | 探索/发现链接 | 短视频/主页链接 |
| 短链支持 | 是 | 是 | 是 |
| 用户认证 | Cookie | Cookie | Cookie |
| 反爬机制 | 中等 | 较高 | 较高 |
| 数据完整性 | 高 | 中等 | 中等 |
| 稳定性 | 高 | 中等 | 中等 |

### 数据结构对比

| 数据字段 | TikTok | 小红书 | 快手 |
|----------|--------|--------|------|
| 视频ID | `id` | `id` | `photoId` |
| 标题 | `desc` | `title` | `caption` |
| 时长 | `video.duration` | `video.duration` | `duration` |
| 作者信息 | `author` | `user` | `user` |
| 播放地址 | `video.download_addr` | `video.play_addr` | 需要构建 |
| 封面图 | `video.cover` | `video.cover` | `photo.coverUrl` |
| 统计数据 | `stats` | `interact_info` | `photo` |
| 创建时间 | `create_time` | `create_time` | `timestamp` |

### 技术挑战与解决方案

#### 1. 反爬机制应对

**TikTok**:
- 使用移动端 API 降低检测风险
- 模拟真实设备 User-Agent
- 支持自定义 Cookie

**小红书**:
- 解析客户端渲染数据而非直接抓取
- 使用浏览器 User-Agent
- 处理短链接重定向

**快手**:
- 解析 Apollo State 避免直接 API 调用
- 支持多种 CDN 节点
- 处理复杂的数据结构

#### 2. 数据获取稳定性

**问题**：
- API 接口变化频繁
- 网页结构经常更新
- 反爬机制不断加强

**解决方案**：
- 采用灵活的数据解析策略
- 实现错误处理和重试机制
- 提供配置化的参数设置
- 支持代理和自定义请求头

#### 3. 多媒体内容处理

**视频内容**：
- 直接提取视频流地址
- 支持多种分辨率选择
- 处理不同编码格式

**图文内容**：
- 批量下载图片资源
- 保持图片原始质量
- 处理图片压缩和优化

## 下载管理器设计

### 核心功能

```go
type DownloadManager struct {
    workers    int
    taskQueue  chan *DownloadTask
    activeJobs map[string]*DownloadJob
    storage    Storage
    downloader Downloader
    logger     *zerolog.Logger
}
```

### 关键特性

1. **并发控制**：可配置的工作线程数量
2. **进度跟踪**：实时下载进度反馈
3. **断点续传**：支持中断后继续下载
4. **错误处理**：自动重试和错误记录
5. **速度限制**：防止被封禁的限速机制

### 下载流程

```
1. 接收下载任务
2. 验证 URL 有效性
3. 提取视频信息
4. 创建下载任务
5. 分配下载线程
6. 执行文件下载
7. 更新下载进度
8. 完成后更新状态
```

## 存储层设计

### 数据库模式

```sql
-- 视频信息表
CREATE TABLE videos (
    id VARCHAR(255) PRIMARY KEY,
    platform VARCHAR(50) NOT NULL,
    title TEXT,
    description TEXT,
    url TEXT NOT NULL,
    download_url TEXT,
    thumbnail TEXT,
    duration INTEGER,
    media_type VARCHAR(20),
    size BIGINT,
    format VARCHAR(10),
    quality VARCHAR(10),
    author_id VARCHAR(255),
    author_name VARCHAR(255),
    author_avatar TEXT,
    view_count INTEGER DEFAULT 0,
    like_count INTEGER DEFAULT 0,
    share_count INTEGER DEFAULT 0,
    comment_count INTEGER DEFAULT 0,
    published_at DATETIME,
    collected_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    downloaded_at DATETIME,
    file_path TEXT,
    file_size BIGINT,
    download_path TEXT,
    status VARCHAR(20) DEFAULT 'pending',
    retry_count INTEGER DEFAULT 0,
    error_message TEXT,
    metadata TEXT,
    extract_from VARCHAR(20)
);

-- 下载任务表
CREATE TABLE download_tasks (
    id VARCHAR(255) PRIMARY KEY,
    video_id VARCHAR(255),
    url TEXT NOT NULL,
    platform VARCHAR(50),
    status VARCHAR(20) DEFAULT 'pending',
    progress FLOAT DEFAULT 0,
    speed VARCHAR(50),
    eta VARCHAR(50),
    file_path TEXT,
    error TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    started_at DATETIME,
    completed_at DATETIME
);

-- 作者信息表
CREATE TABLE authors (
    id VARCHAR(255) PRIMARY KEY,
    platform VARCHAR(50) NOT NULL,
    name VARCHAR(255),
    nickname VARCHAR(255),
    avatar TEXT,
    description TEXT,
    followers INTEGER DEFAULT 0,
    following INTEGER DEFAULT 0,
    video_count INTEGER DEFAULT 0,
    verified BOOLEAN DEFAULT FALSE,
    collected_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

### 存储接口

```go
type Storage interface {
    // 视频信息管理
    SaveVideoInfo(info *VideoInfo) error
    GetVideoInfo(id string) (*VideoInfo, error)
    ListVideos(filter VideoFilter) ([]*VideoInfo, error)
    UpdateVideoStatus(id, status string) error

    // 下载任务管理
    SaveDownloadTask(task *DownloadTask) error
    GetDownloadTask(id string) (*DownloadTask, error)
    UpdateDownloadProgress(id string, progress float64) error

    // 作者信息管理
    SaveAuthorInfo(info *AuthorInfo) error
    GetAuthorInfo(platform Platform, id string) (*AuthorInfo, error)

    // 统计信息
    GetStats() (*Stats, error)
    GetRecentDownloads(limit int) ([]*VideoInfo, error)
    GetFailedDownloads() ([]*VideoInfo, error)
}
```

## 配置管理

### 配置文件结构

```yaml
server:
  host: 0.0.0.0
  port: 8080
  read_timeout: 30
  write_timeout: 30

download:
  max_workers: 5
  chunk_size: 1048576  # 1MB
  timeout: 300
  retry_count: 3
  save_path: ./downloads
  create_folder: true
  file_naming: "{platform}_{author}_{title}_{id}"

database:
  type: sqlite
  path: ./data/video-downloader.db
  max_conns: 10

proxy:
  enabled: false
  type: http
  host: ""
  port: 0
  username: ""
  password: ""

platforms:
  tiktok:
    enabled: true
    cookie: ""
    user_agent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X)"

  xhs:
    enabled: true
    cookie: ""
    user_agent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"

  kuaishou:
    enabled: true
    cookie: ""
    user_agent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
```

### 配置管理实现

```go
type ConfigManager struct {
    config     *Config
    configPath string
    mutex      sync.RWMutex
}

func (cm *ConfigManager) Load() error {
    data, err := os.ReadFile(cm.configPath)
    if err != nil {
        return fmt.Errorf("error reading config file: %w", err)
    }

    cm.mutex.Lock()
    defer cm.mutex.Unlock()

    if err := yaml.Unmarshal(data, &cm.config); err != nil {
        return fmt.Errorf("error parsing config file: %w", err)
    }

    return nil
}

func (cm *ConfigManager) Save() error {
    cm.mutex.RLock()
    defer cm.mutex.RUnlock()

    data, err := yaml.Marshal(cm.config)
    if err != nil {
        return fmt.Errorf("error marshaling config: %w", err)
    }

    if err := os.WriteFile(cm.configPath, data, 0644); err != nil {
        return fmt.Errorf("error writing config file: %w", err)
    }

    return nil
}
```

## 监控与指标

### 关键指标

```go
type Metrics struct {
    TotalDownloads     int64
    SuccessfulDownloads int64
    FailedDownloads    int64
    TotalBytes        int64
    AverageSpeed      float64
    ActiveWorkers     int
    QueueLength       int
    PlatformStats     map[Platform]*PlatformMetrics
}

type PlatformMetrics struct {
    TotalRequests    int64
    SuccessfulRequests int64
    FailedRequests   int64
    AverageResponseTime float64
    LastSuccess      time.Time
    LastFailure      time.Time
}
```

### 指标收集

```go
type Monitor struct {
    metrics     *Metrics
    storage     Storage
    registry    *Registry
    logger      *zerolog.Logger
    interval    time.Duration
    stopChan    chan struct{}
}

func (m *Monitor) Start() {
    ticker := time.NewTicker(m.interval)
    go func() {
        for {
            select {
            case <-ticker.C:
                m.collectMetrics()
            case <-m.stopChan:
                ticker.Stop()
                return
            }
        }
    }()
}

func (m *Monitor) collectMetrics() {
    stats, err := m.storage.GetStats()
    if err != nil {
        m.logger.Error().Err(err).Msg("Failed to collect stats")
        return
    }

    m.metrics.TotalDownloads = stats.TotalVideos
    m.metrics.SuccessfulDownloads = stats.TotalVideos - stats.FailedDownloads
    m.metrics.FailedDownloads = stats.FailedDownloads
    m.metrics.TotalBytes = stats.TotalSize
    m.metrics.AverageSpeed = stats.AvgDownloadSpeed
}
```

## 部署与运维

### Docker 部署

```dockerfile
FROM golang:1.21-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -o video-downloader ./cmd/cli

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/

COPY --from=builder /app/video-downloader .
COPY --from=builder /app/config ./config

EXPOSE 8080
CMD ["./video-downloader", "server"]
```

### Docker Compose

```yaml
version: '3.8'

services:
  video-downloader:
    build: .
    ports:
      - "8080:8080"
    volumes:
      - ./data:/app/data
      - ./downloads:/app/downloads
      - ./config:/app/config
    environment:
      - VD_SERVER_PORT=8080
      - VD_DATABASE_PATH=/app/data/video-downloader.db
      - VD_DOWNLOAD_SAVE_PATH=/app/downloads
    restart: unless-stopped

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - video-downloader
    restart: unless-stopped
```

### 监控配置

```yaml
# prometheus.yml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'video-downloader'
    static_configs:
      - targets: ['localhost:8080']
    metrics_path: '/metrics'
    scrape_interval: 15s
```

## 扩展性设计

### 新平台接入

1. **实现 PlatformExtractor 接口**
2. **注册新平台**
3. **配置平台参数**
4. **测试验证**

```go
// 示例：添加新平台
type NewPlatformExtractor struct {
    client *utils.HTTPClient
    config *models.ExtractorConfig
}

func (e *NewPlatformExtractor) ExtractVideoInfo(url string) (*models.VideoInfo, error) {
    // 实现视频信息提取逻辑
}

func (e *NewPlatformExtractor) ValidateURL(url string) bool {
    // 实现 URL 验证逻辑
}

// 注册平台
func init() {
    registry.Register("newplatform", func(config *models.ExtractorConfig) models.PlatformExtractor {
        return &NewPlatformExtractor{
            client: utils.NewHTTPClient(...),
            config: config,
        }
    })
}
```

### 插件系统

```go
type Plugin interface {
    Name() string
    Version() string
    Init(config map[string]interface{}) error
    Extract(url string) (*VideoInfo, error)
    Close() error
}

type PluginManager struct {
    plugins map[string]Plugin
    mutex   sync.RWMutex
}

func (pm *PluginManager) LoadPlugin(path string) error {
    // 动态加载插件
    plugin, err := plugin.Open(path)
    if err != nil {
        return err
    }

    sym, err := plugin.Lookup("New")
    if err != nil {
        return err
    }

    newFunc, ok := sym.(func() Plugin)
    if !ok {
        return fmt.Errorf("unexpected type from module symbol")
    }

    p := newFunc()
    pm.plugins[p.Name()] = p
    return nil
}
```

## 安全考虑

### 输入验证

```go
func ValidateURL(url string) error {
    if url == "" {
        return errors.New("URL cannot be empty")
    }

    parsedURL, err := url.Parse(url)
    if err != nil {
        return fmt.Errorf("invalid URL format: %w", err)
    }

    if parsedURL.Scheme != "http" && parsedURL.Scheme != "https" {
        return errors.New("only HTTP and HTTPS URLs are supported")
    }

    // 检查是否为支持的域名
    supportedDomains := map[string]bool{
        "tiktok.com":      true,
        "vm.tiktok.com":   true,
        "xiaohongshu.com": true,
        "xhslink.com":     true,
        "kuaishou.com":    true,
        "v.kuaishou.com":  true,
    }

    if !supportedDomains[parsedURL.Host] {
        return fmt.Errorf("unsupported domain: %s", parsedURL.Host)
    }

    return nil
}
```

### 速率限制

```go
type RateLimiter struct {
    limiter    *rate.Limiter
    window     time.Duration
    maxRequests int
    requests   map[string][]time.Time
    mutex      sync.RWMutex
}

func (rl *RateLimiter) Allow(key string) bool {
    rl.mutex.Lock()
    defer rl.mutex.Unlock()

    now := time.Now()
    requests := rl.requests[key]

    // 清理过期的请求记录
    var validRequests []time.Time
    for _, req := range requests {
        if now.Sub(req) < rl.window {
            validRequests = append(validRequests, req)
        }
    }

    if len(validRequests) >= rl.maxRequests {
        return false
    }

    validRequests = append(validRequests, now)
    rl.requests[key] = validRequests
    return true
}
```

### 错误处理

```go
func (e *Extractor) handleError(err error, context string) error {
    var apiErr *APIError
    var netErr net.Error
    var timeoutErr timeout.Error

    switch {
    case errors.As(err, &apiErr):
        e.logger.Error().
            Str("context", context).
            Int("status_code", apiErr.StatusCode).
            Str("message", apiErr.Message).
            Msg("API error occurred")
        return fmt.Errorf("%s: API error (status: %d): %s", context, apiErr.StatusCode, apiErr.Message)

    case errors.As(err, &netErr):
        e.logger.Error().
            Str("context", context).
            Err(err).
            Msg("Network error occurred")
        return fmt.Errorf("%s: network error: %w", context, err)

    case errors.As(err, &timeoutErr):
        e.logger.Error().
            Str("context", context).
            Err(err).
            Msg("Timeout error occurred")
        return fmt.Errorf("%s: timeout error: %w", context, err)

    default:
        e.logger.Error().
            Str("context", context).
            Err(err).
            Msg("Unknown error occurred")
        return fmt.Errorf("%s: unknown error: %w", context, err)
    }
}
```

## 性能优化

### 并发下载

```go
func (dm *DownloadManager) downloadWorker(id int) {
    for task := range dm.taskQueue {
        dm.logger.Info().
            Str("worker_id", fmt.Sprintf("%d", id)).
            Str("task_id", task.ID).
            Msg("Starting download task")

        start := time.Now()

        // 执行下载
        err := dm.downloader.Download(task.URL, task.FilePath, task.ProgressChan)

        duration := time.Since(start)

        if err != nil {
            dm.logger.Error().
                Str("worker_id", fmt.Sprintf("%d", id)).
                Str("task_id", task.ID).
                Err(err).
                Dur("duration", duration).
                Msg("Download task failed")

            task.Status = "failed"
            task.Error = err.Error()
        } else {
            dm.logger.Info().
                Str("worker_id", fmt.Sprintf("%d", id)).
                Str("task_id", task.ID).
                Dur("duration", duration).
                Msg("Download task completed successfully")

            task.Status = "completed"
            task.CompletedAt = &time.Time{}
        }

        // 更新任务状态
        if err := dm.storage.UpdateDownloadTask(task); err != nil {
            dm.logger.Error().
                Str("task_id", task.ID).
                Err(err).
                Msg("Failed to update download task")
        }

        delete(dm.activeJobs, task.ID)
    }
}
```

### 内存管理

```go
func (dm *DownloadManager) cleanup() {
    ticker := time.NewTicker(5 * time.Minute)
    defer ticker.Stop()

    for {
        select {
        case <-ticker.C:
            dm.mutex.Lock()

            // 清理已完成的任务
            for id, job := range dm.activeJobs {
                if job.Status == "completed" || job.Status == "failed" {
                    if time.Since(job.UpdatedAt) > 30*time.Minute {
                        delete(dm.activeJobs, id)
                        dm.logger.Info().
                            Str("task_id", id).
                            Msg("Cleaned up old download task")
                    }
                }
            }

            dm.mutex.Unlock()

        case <-dm.stopChan:
            return
        }
    }
}
```

### 缓存机制

```go
type Cache struct {
    store  map[string]*CacheEntry
    mutex  sync.RWMutex
    ttl    time.Duration
}

type CacheEntry struct {
    Value      interface{}
    Expiration time.Time
}

func (c *Cache) Get(key string) (interface{}, bool) {
    c.mutex.RLock()
    defer c.mutex.RUnlock()

    entry, exists := c.store[key]
    if !exists {
        return nil, false
    }

    if time.Now().After(entry.Expiration) {
        return nil, false
    }

    return entry.Value, true
}

func (c *Cache) Set(key string, value interface{}, ttl time.Duration) {
    c.mutex.Lock()
    defer c.mutex.Unlock()

    c.store[key] = &CacheEntry{
        Value:      value,
        Expiration: time.Now().Add(ttl),
    }
}
```

## 测试策略

### 单元测试

```go
func TestTikTokExtractor_ExtractVideoInfo(t *testing.T) {
    extractor := NewTikTokExtractor(&models.ExtractorConfig{
        Timeout:    30 * time.Second,
        MaxRetries: 3,
    })

    tests := []struct {
        name    string
        url     string
        wantErr bool
    }{
        {
            name:    "Valid TikTok URL",
            url:     "https://www.tiktok.com/@test/video/1234567890",
            wantErr: false,
        },
        {
            name:    "Invalid TikTok URL",
            url:     "https://example.com/video",
            wantErr: true,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            info, err := extractor.ExtractVideoInfo(tt.url)

            if tt.wantErr {
                assert.Error(t, err)
                return
            }

            assert.NoError(t, err)
            assert.NotEmpty(t, info.ID)
            assert.Equal(t, models.PlatformTikTok, info.Platform)
        })
    }
}
```

### 集成测试

```go
func TestDownloadManager_Integration(t *testing.T) {
    if testing.Short() {
        t.Skip("Skipping integration test")
    }

    storage := NewTestStorage()
    downloader := NewTestDownloader()

    manager := NewDownloadManager(DownloadManagerConfig{
        MaxWorkers: 2,
        Storage:    storage,
        Downloader: downloader,
    })

    task := &DownloadTask{
        ID:        "test-task",
        URL:       "https://example.com/video.mp4",
        FilePath:  "/tmp/test.mp4",
        Status:    "pending",
    }

    err := manager.AddTask(task)
    assert.NoError(t, err)

    // 等待下载完成
    time.Sleep(5 * time.Second)

    updatedTask, err := storage.GetDownloadTask(task.ID)
    assert.NoError(t, err)
    assert.Equal(t, "completed", updatedTask.Status)
}
```

### 性能测试

```go
func BenchmarkExtractor_ExtractVideoInfo(b *testing.B) {
    extractor := NewTikTokExtractor(&models.ExtractorConfig{
        Timeout:    30 * time.Second,
        MaxRetries: 3,
    })

    url := "https://www.tiktok.com/@test/video/1234567890"

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _, err := extractor.ExtractVideoInfo(url)
        if err != nil {
            b.Fatalf("ExtractVideoInfo failed: %v", err)
        }
    }
}
```

## 总结

本视频下载器项目采用了现代化的软件架构设计，具有以下特点：

### 技术优势

1. **模块化设计**：各平台独立实现，易于维护和扩展
2. **接口抽象**：统一的接口设计，支持多种实现方式
3. **并发处理**：高效的并发下载机制，提升下载效率
4. **错误处理**：完善的错误处理和重试机制
5. **监控指标**：全面的监控和指标收集
6. **配置管理**：灵活的配置系统，适应不同环境

### 技术挑战

1. **反爬机制**：各平台反爬策略不同，需要针对性处理
2. **接口变化**：平台 API 和网页结构经常变化
3. **性能优化**：大量并发下载的性能优化
4. **数据一致性**：确保数据存储的一致性和完整性

### 未来发展方向

1. **AI 技术应用**：使用 AI 技术提高数据提取准确性
2. **云原生架构**：支持 Kubernetes 等云原生部署
3. **微服务化**：将各功能模块拆分为独立服务
4. **实时处理**：支持实时视频流处理
5. **国际化支持**：支持更多国际平台

本项目展示了如何在复杂的网络环境下构建稳定、高效的数据采集系统，为类似的技术需求提供了有价值的参考。